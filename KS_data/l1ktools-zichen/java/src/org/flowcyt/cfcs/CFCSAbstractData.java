package org.flowcyt.cfcs;
// CFCSAbstractData.java

/* ------------------------------------------------------------------------- *\
This software and documentation are provided 'as is' and Tree Star, Inc., its
contractors and partners specifically disclaim all other warranties, expressed
or implied, including but not limited to implied warranties of merchantability
and fitness for a particular purpose, or during any particular date range.

By using this software, you are agreeing to these limits of liability, and to
hold Tree Star harmless for any information, accurate or erroneous, that might
be generated by the program.  This software is intended for research use only.

Christopher Lane <cdl@best.classes> for Tree Star  1/16/2002      Copyright 2002
\* ------------------------------------------------------------------------- */




public abstract class CFCSAbstractData implements CFCSData, CFCSErrorCodes
{

    protected static final int BITSPERBYTE = 8;

    protected int type = UNDEFINED;
    protected final CFCSDatatype datatype;
    protected final CFCSKeywords keywords;
    protected final CFCSParameters parameters;
    protected CFCSDataSizing sizing;
    protected byte[][][] cinched;

    protected final static int[] JAVA_BYTESWAP_ARRAY = {4, 3, 2, 1};

    // --------------------------------------------------------------------

    CFCSAbstractData(final int type, final CFCSDatatype datatype, final CFCSKeywords keywords)
    {
        this.type = type;
        this.datatype = datatype;
        this.keywords = keywords;

        this.parameters = new CFCSParameters(keywords);

        if (keywords.getSystemKeyword(CFCSKeywords.BYTEORDER_KEYWORD) == null)
        {
            keywords.setByteSwapArray(JAVA_BYTESWAP_ARRAY);
        }
    }

    // --------------------------------------------------------------------

    public final int getType()
    {
        return type;
    }

    // --------------------------------------------------------------------

    protected byte[] packBytes(final byte[] bytes)
    {
        throw new CFCSError(CFCSNotImplemented);
    }

    // --------------------------------------------------------------------

    protected byte[] unpackBytes(final byte[] bytes)
    {
        throw new CFCSError(CFCSNotImplemented);
    }

    // --------------------------------------------------------------------

    protected abstract byte[][][] cinchBytes(byte[] bytes);

    // --------------------------------------------------------------------

    public abstract byte[] getBytes();

    // --------------------------------------------------------------------

    public void setBytes(byte[] bytes)
    {
        if (sizing.isPackedData())
        {
            bytes = unpackBytes(bytes);
        }

        this.cinched = cinchBytes(bytes);

        if (keywords.getDatatype() != CFCSDatatype.ASCII)
            swapCinchedBytes();
    }

    // --------------------------------------------------------------------

    protected final void swapCinchedBytes()
    {
        final int[] swap = keywords.getByteSwapArray();

        for (int outer = 0; outer < cinched.length; outer++)
        {
            for (int inner = 0; inner < cinched[outer].length; inner++)
            {
                byte[] cinch = cinched[outer][inner];

                int nBytes = cinch.length;

                if (nBytes == 1)
                    continue;
                /* else */ if (nBytes > 2 && (nBytes % 4) != 0)
                {
                    throw new CFCSError(CFCSNotImplemented, "swapCinchedBytes(" + nBytes + ")");
                }

                byte[] temporary = new byte[nBytes];

                int sBytes = nBytes % swap.length; // Can only swap so many at a time
                if (sBytes == 0)
                    sBytes = swap.length;

                for (int swaps = 0; swaps < nBytes; swaps += sBytes)
                {
                    for (int i = 0; i < sBytes; i++)
                    {
                        temporary[i + swaps] = cinch[swaps + ((swap[(swap.length - 1) - i] - 1) % sBytes)];
                    }
                }

                for (int i = 0; i < nBytes; i++)
                    cinch[i] = temporary[i];
            }
        }
    }

    // --------------------------------------------------------------------

    public final int getCount()
    {
        CFCSKeyword keyword = null;

        try
        {
            keyword = keywords.getKeyword(CFCSKeywords.TOTAL_KEYWORD);
        }
        catch (CFCSError error)
        {
            return 0;
        }

        return keyword.getKeywordIntegerValue();
    }

    // --------------------------------------------------------------------

    protected final void setCount(final int count)
    {
        keywords.addSystemKeyword(new CFCSKeyword(CFCSKeywords.TOTAL_KEYWORD, count));
    }

    // --------------------------------------------------------------------

    protected final void addCount(final int count)
    {
        CFCSKeyword keyword = null;

        try
        {
            keyword = keywords.getKeyword(CFCSKeywords.TOTAL_KEYWORD);
        }
        catch (CFCSError exception)
        {
            keyword = new CFCSKeyword(CFCSKeywords.TOTAL_KEYWORD, 0);
        }

        keyword.setKeywordIntegerValue(count + keyword.getKeywordIntegerValue());

        keywords.addSystemKeyword(keyword);
    }

    // --------------------------------------------------------------------

    protected static final boolean isDelimiter(final char c)
    {
        return (Character.isWhitespace(c) || c == CFCSSystem.VALUE_SEPARATOR_CHAR);
    }

    // --------------------------------------------------------------------

}
