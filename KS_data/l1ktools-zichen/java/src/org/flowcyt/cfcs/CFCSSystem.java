package org.flowcyt.cfcs;

// CFCSSystem.java

/* ------------------------------------------------------------------------- *\
 This software and documentation are provided 'as is' and Tree Star, Inc., its
 contractors and partners specifically disclaim all other warranties, expressed
 or implied, including but not limited to implied warranties of merchantability
 and fitness for a particular purpose, or during any particular date range.

 By using this software, you are agreeing to these limits of liability, and to
 hold Tree Star harmless for any information, accurate or erroneous, that might
 be generated by the program.  This software is intended for research use only.

 Christopher Lane <cdl@best.classes> for Tree Star  1/21/2002      Copyright 2002
 \* ------------------------------------------------------------------------- */

import java.io.BufferedInputStream;
import java.io.BufferedOutputStream;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.net.MalformedURLException;
import java.net.URL;
import java.net.URLConnection;
import java.util.ArrayList;
import java.util.List;

public final class CFCSSystem implements CFCSErrorCodes {
    private final List datasets = new ArrayList();
    private URLConnection connection;
    private FileOutputStream fos;

    // private static final String CFCS_VERSION = "0.31 (alpha) / API v01.10";
    // JS, change 0.31->0.32
    private static final String CFCS_VERSION = "0.32 (alpha) / API v01.10";

    private static final byte PAD_BYTE = 32;

    /* friendly */
    static final char PAD_CHAR = ' ';
    /* friendly */
    static final char VALUE_SEPARATOR_CHAR = ',';

    // /* friendly */
    static final int BITSPERBYTE = 8;

    // --------------------------------------------------------------------
    // The CFCS API Implementation Version, not the FCS file version

    public static final String getVersion() {
	return CFCS_VERSION;
    }

    // Josef Spidlen,
    //
    // Calculating 16-bit CRC
    // Calculating CRC with 16-bit CRC-CCITT specification as described in FCS3.0, which is:
    // Width = 16 bits
    // Truncated polynomial = 0x1021 (= x^16 + x^12 + x^5 + 1)
    // Initial value = 0xFFFF (private static final int initvalue)
    // Input data is bit-reversed (private static final boolean bReverseBits)
    // - note that this seems to be FCS3.0 specification only, the CCITT doesn't require
    // to reverse bits of the input bytes
    // Output CRC is NOT reflected
    // No XOR is performed on the output CRC
    //
    // - note that sun.misc.CRC16 calculate another CRC
    public static class CRC16_CCITT {

	private int work = initvalue;
	public int value = initvalue; // just a public copy of work (to be similar to
	// sun.misc.CRC16)

	/**
	 * generator polynomial
	 */
	private static final int poly = 0x1021; /* x16 + x12 + x5 + 1 generator polynomial */
	/* 0x8408 used in European X.25 */
	/* 0x8005 used in CRC16 */

	private static final int initvalue = 0xffff;
	private static final boolean bReverseBits = true;

	/**
	 * scrambler lookup table for fast computation.
	 */
	private static int[] crcTable = new int[256];
	static {
	    // initialise scrambler table
	    for (int i = 0; i < 256; i++) {
		int fcs = 0;
		int d = i << 8;
		for (int k = 0; k < 8; k++) {
		    if (((fcs ^ d) & 0x8000) != 0) {
			fcs = (fcs << 1) ^ poly;
		    } else {
			fcs = (fcs << 1);
		    }
		    d <<= 1;
		    fcs &= 0xffff;
		}
		crcTable[i] = fcs;
	    }
	}

	public void update(byte b) {
	    byte bx;
	    if (bReverseBits)
		bx = ReverseBits(b);
	    else
		bx = b;
	    work = (crcTable[(bx ^ (work >>> 8)) & 0xff] ^ (work << 8)) & 0xffff;
	    value = work;
	}

	public void reset() {
	    value = initvalue;
	    work = initvalue;
	}

	public String toString() {
	    return new Integer(work).toString();
	}

	private static byte ReverseBits(byte b) {

	    return (byte) (((b & (byte) (0x01 << 0)) << 7) | ((b & (byte) (0x01 << 1)) << 5)
		    | ((b & (byte) (0x01 << 2)) << 3) | ((b & (byte) (0x01 << 3)) << 1)
		    | ((b & (byte) (0x01 << 4)) >> 1) | ((b & (byte) (0x01 << 5)) >> 3)
		    | ((b & (byte) (0x01 << 6)) >> 5) | ((b & (byte) (0x01 << 7)) >> 7));

	}

    }

    // --------------------------------------------------------------------
    // A buffered input stream that keeps track of where it is in a file.

    /* friendly inner */
    static final class SentientInputStream extends BufferedInputStream {
	protected long filePointer = 0;

	// JS:
	// note that sun.misc.CRC16 calculates a diffrent CRC
	// protected sun.misc.CRC16 crc16 = new sun.misc.CRC16();
	protected CRC16_CCITT crc16 = new CRC16_CCITT();

	/* friendly */
	// JS
	public int getCRC16() {
	    return this.crc16.value;
	}

	/* friendly */
	final long getFilePointer() {
	    return filePointer;
	}

	/* friendly */
	final void resetFilePointer() {
	    filePointer = 0;
	    // JS
	    crc16.reset();
	}

	// JS
	final void resetCRC() {
	    // Uncomment to trace the CRC computation
	    // System.out.println("CRC value: " + crc16.value + " reset to " + CRC16_CCITT.initvalue
	    // + ".");
	    crc16.reset();
	}

	public SentientInputStream(final InputStream in) {
	    super(in);
	}

	public SentientInputStream(final InputStream in, final int size) {
	    super(in, size);
	}

	public final boolean markSupported() {
	    return false;
	}

	// ------------------------------------------------------------

	public final int read() throws IOException {
	    final int result = super.read();

	    // JS
	    // Uncomment to trace the CRC computation
	    if (result != -1) {
		filePointer += 1;
		// JS
		// int old = crc16.value;
		crc16.update((byte) result);
		// System.out.println("CRC value: " + old + " updated by character " + (byte)result
		// + " ('" + (char)result + "') to new value of: " + crc16.value);
	    }

	    return result;
	}

	// ------------------------------------------------------------

	public final int read(final byte[] b, final int off, final int len) throws IOException {
	    final int bytes = super.read(b, off, len);
	    filePointer += bytes;

	    // JS
	    // Uncomment to trace the CRC computation
	    // int old;
	    for (int i = 0; i < bytes; i++) {
		// old = crc16.value;
		crc16.update(b[i]);
		// System.out.println("CRC value: " + old + " updated by character " + b[i] + " ('"
		// + (char)b[i] + "') to new value of: " + crc16.value);
	    }

	    return bytes;
	}

	// ------------------------------------------------------------

	public final long skip(final long n) throws IOException {
	    // JS: Cannot skip because of CRC, need to read it
	    // Code changed

	    long skipped = 0;
	    int nByte;

	    for (int i = 0; i < n; i++) {
		// updates CRC as well as the filePointer
		if (read() != -1)
		    skipped++;
	    }
	    return skipped;
	}

	// ------------------------------------------------------------

    }

    // --------------------------------------------------------------------
    // A buffered output stream that keeps track of where it is in a file.

    /* friendly inner */
    static final class SentientOutputStream extends BufferedOutputStream {
	protected long filePointer = 0;

	/* friendly */
	final long getFilePointer() {
	    return filePointer;
	}

	/* friendly */
	final void resetFilePointer() {
	    filePointer = 0;
	}

	public SentientOutputStream(final OutputStream out) {
	    super(out);
	}

	public SentientOutputStream(final OutputStream out, final int size) {
	    super(out, size);
	}

	// ------------------------------------------------------------

	public final void write(final int b) throws IOException {
	    super.write(b);

	    filePointer += 1;
	}

	// ------------------------------------------------------------

	public final void write(final byte[] b, final int off, final int len) throws IOException {
	    super.write(b, off, len);

	    filePointer += b.length;
	}

	// ------------------------------------------------------------

	public final void skip(final long n) throws IOException {
	    for (int i = 0; i < n; i++)
		this.write(PAD_BYTE);
	}

	// ------------------------------------------------------------

    }

    // --------------------------------------------------------------------

    private void setFileKeyword(final CFCSDataSet dataset) {
	final URL url = connection.getURL();

	final CFCSKeywords keywords = dataset.getKeywords();

	keywords.addSystemKeyword(new CFCSKeyword(CFCSKeywords.FILE_KEYWORD, url.getFile()));
    }

    // --------------------------------------------------------------------

    public final void open(final String URL) {
	URL url;

	try {
	    url = new URL(URL);
	} catch (MalformedURLException exception) {
	    throw new CFCSError(CFCSFileNotFound, exception.getMessage());
	}

	open(url);
    }

    public final void open(URL url) {
	InputStream stream;
	try {
	    stream = url.openStream();
	    open(stream);
	} catch (IOException e) {
	    throw new CFCSError(CFCSIOError, e.getMessage());
	}

    }

    public final void open(InputStream stream) {
	try {

	    long offset, start = 0;

	    SentientInputStream sentient = new SentientInputStream(stream);

	    do {
		sentient.resetFilePointer();

		CFCSDataSet dataset = new CFCSDataSet(sentient);

		datasets.add(dataset);

		CFCSKeywords keywords = dataset.getKeywords();

		try {
		    CFCSKeyword nextdata = keywords.getKeyword(CFCSKeywords.NEXTDATA_KEYWORD);

		    start = nextdata.getKeywordIntegerValue();

		    if (start > 0 && (offset = sentient.getFilePointer()) < start) {
			sentient.skip(start - offset);
		    }
		} catch (CFCSError error) {
		    break;
		}
	    } while (start > 0);

	    stream.close();
	} catch (IOException exception) {
	    throw new CFCSError(CFCSIOError, exception.getMessage());
	}
    }

    // --------------------------------------------------------------------

    public final void create(final String URL) {
	URL url;

	try {
	    url = new URL(URL);
	} catch (MalformedURLException exception) {
	    throw new CFCSError(CFCSFileNotFound, exception.getMessage());
	}

	try {
	    connection = url.openConnection();
	} catch (IOException exception) {
	    throw new CFCSError(CFCSFileNotCreated, exception.getMessage());
	}
    }

    // creates a file output stream for writing an fcs file from loaded data.
    public final void createLocal(final String path) {
	File file;

	file = new File(path);

	try {
	    fos = new FileOutputStream(file);
	} catch (FileNotFoundException e) {
	    e.printStackTrace();
	}

    }

    // --------------------------------------------------------------------
    // Not an official API entry point. Allows you to open, modify and save
    // out an FCS file. Modifications are limited to editing non-system keywords.

    public final void modify(final String source, final String destination) {
	open(source);
	create(destination);
    }

    // --------------------------------------------------------------------

    public final int getCount() {
	return datasets.size();
    }

    // --------------------------------------------------------------------

    public final CFCSDataSet getDataSet(final int setIdx) {
	if (setIdx < 0 || setIdx > datasets.size() - 1) {
	    throw new CFCSError(CFCSNoSuchDataSet);
	}

	return (CFCSDataSet) datasets.get(setIdx);
    }

    // --------------------------------------------------------------------

    public final CFCSDataSet createDataSet(final int mode) {
	return createDataSet(mode, CFCSDataSet.DEFAULT_DATATYPE);
    }

    // --------------------------------------------------------------------

    public final CFCSDataSet createDataSet(final int mode, final int type) {
	if (mode != CFCSData.LISTMODE && mode != CFCSData.CORRELATED
		&& mode != CFCSData.UNCORRELATED) {
	    throw new CFCSError(CFCSNoSuchDataSet, mode);
	}

	CFCSDataSet dataset = new CFCSDataSet(mode, type);

	datasets.add(dataset);

	setFileKeyword(dataset);

	return dataset;
    }

    // --------------------------------------------------------------------

    public final CFCSDataSet createDataSet(final CFCSDataSet source) {
	final CFCSDataSet dataset = new CFCSDataSet(source);

	datasets.add(dataset);

	setFileKeyword(dataset);

	return dataset;
    }

    // --------------------------------------------------------------------

    public final void deleteDataSet(final int setIdx) {
	if (setIdx < 0 || setIdx > datasets.size() - 1) {
	    throw new CFCSError(CFCSNoSuchDataSet, setIdx);
	}
	/* else */datasets.remove(setIdx);
    }

    // --------------------------------------------------------------------

    public final void close() {
	if (connection != null) {
	    URL url = connection.getURL();

	    String path = url.getPath();

	    try {
		OutputStream stream;

		if ("file".equalsIgnoreCase(url.getProtocol())) {
		    stream = new FileOutputStream(path);
		} else
		    stream = connection.getOutputStream();

		SentientOutputStream sentient = new SentientOutputStream(stream);

		long next = 0L;

		for (int i = 0, count = getCount(); i < count; i++) {
		    sentient.resetFilePointer();
		    CFCSDataSet dataset = getDataSet(i);
		    dataset.writeDataSet(sentient, (i < (count - 1)) ? next : -1L);

		    next += sentient.getFilePointer();
		}

		sentient.close();
	    } catch (IOException exception) {
		throw new CFCSError(CFCSFileNotCreated, exception.getMessage());
	    }
	}
    }

    // used to create a local fcs file from data read in
    public final void closeLocal() {
	if (fos != null) {
	    try {
		SentientOutputStream sentient = new SentientOutputStream(fos);

		long next = 0L;

		for (int i = 0, count = getCount(); i < count; i++) {
		    sentient.resetFilePointer();
		    CFCSDataSet dataset = getDataSet(i);
		    dataset.writeDataSet(sentient, (i < (count - 1)) ? next : -1L);

		    next += sentient.getFilePointer();
		}
		sentient.close();
	    } catch (IOException exception) {
		throw new CFCSError(CFCSFileNotCreated, exception.getMessage());
	    }
	}
    }

    // --------------------------------------------------------------------

}
