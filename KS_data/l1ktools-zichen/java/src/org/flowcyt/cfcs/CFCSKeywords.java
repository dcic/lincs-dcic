package org.flowcyt.cfcs;
// CFCSKeywords.java

/* ------------------------------------------------------------------------- *\
This software and documentation are provided 'as is' and Tree Star, Inc., its
contractors and partners specifically disclaim all other warranties, expressed
or implied, including but not limited to implied warranties of merchantability
and fitness for a particular purpose, or during any particular date range.

By using this software, you are agreeing to these limits of liability, and to
hold Tree Star harmless for any information, accurate or erroneous, that might
be generated by the program.  This software is intended for research use only.

Christopher Lane <cdl@best.classes> for Tree Star  1/18/2002      Copyright 2002
\* ------------------------------------------------------------------------- */


import java.util.HashMap;
import java.util.HashSet;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Set;

public final class CFCSKeywords implements CFCSErrorCodes
{

    /* friendly */
    static final String DATATYPE_KEYWORD = "$DATATYPE";
    /* friendly */
    static final String GATE_KEYWORD = "$GATE";
    /* friendly */
    static final String MODE_KEYWORD = "$MODE";
    /* friendly */
    static final String PARAMETER_KEYWORD = "$PAR";

    /* friendly */
    static final String BYTEORDER_KEYWORD = "$BYTEORD";
    /* friendly */
    static final String FILE_KEYWORD = "$FIL";
    /* friendly */
    static final String NEXTDATA_KEYWORD = "$NEXTDATA";
    /* friendly */
    static final String TOTAL_KEYWORD = "$TOT";

    /* friendly */
    static final Set SYSTEM_KEYWORDS = new HashSet();
    /* friendly */
    static final Set NONTRANSFERABLE_KEYWORDS = new HashSet();

    /* friendly */
    static final String[] SEGMENT_ROOTS = {"HEADER", "STEXT", "DATA", "ANALYSIS"};
    /* friendly */
    static final String SEGMENT_BEGIN_PREFIX = "$BEGIN";
    /* friendly */
    static final String SEGMENT_END_PREFIX = "$END";

    static
    {
        SYSTEM_KEYWORDS.add(DATATYPE_KEYWORD);
        SYSTEM_KEYWORDS.add(GATE_KEYWORD);
        SYSTEM_KEYWORDS.add(MODE_KEYWORD);
        SYSTEM_KEYWORDS.add(PARAMETER_KEYWORD);

        NONTRANSFERABLE_KEYWORDS.add(BYTEORDER_KEYWORD);
        NONTRANSFERABLE_KEYWORDS.add(FILE_KEYWORD);
        NONTRANSFERABLE_KEYWORDS.add(NEXTDATA_KEYWORD);
        NONTRANSFERABLE_KEYWORDS.add(TOTAL_KEYWORD);

        for (int i = CFCSDataSet.TEXT; i < CFCSDataSet.OTHER_START; i++)
        {
            NONTRANSFERABLE_KEYWORDS.add(SEGMENT_BEGIN_PREFIX + SEGMENT_ROOTS[i]);
            NONTRANSFERABLE_KEYWORDS.add(SEGMENT_END_PREFIX + SEGMENT_ROOTS[i]);
        }

        SYSTEM_KEYWORDS.addAll(NONTRANSFERABLE_KEYWORDS);
    }

    private static final char DEFAULT_DELIMITER = '/';
    private static final char DELIMITER_GUARD = '_'; // can't be the same as delimiter
    private static final char[] delimiters = {
        DEFAULT_DELIMITER, '#', '%', '*', '|', '!', '&', '+', ';', '\\', '~',
    };
    private static final char DELIMITER_UNDEFINED = 0;

    private char delimiter = DELIMITER_UNDEFINED;

    private static final int NUMBER = 0, LETTER = 1;

    private static final Object[][] DATATYPE_LOOKUP_TABLE = {
        {new Integer(CFCSDatatype.ASCII), "A"},
        {new Integer(CFCSDatatype.FLOAT), "F"},
        {new Integer(CFCSDatatype.DOUBLE), "D"},
        {new Integer(CFCSDatatype.BINARY), "I"},
    };

    private static final Object[][] MODE_LOOKUP_TABLE = {
        {new Integer(CFCSData.LISTMODE), "L"},
        {new Integer(CFCSData.CORRELATED), "C"},
        {new Integer(CFCSData.UNCORRELATED), "U"},
    };

    private final CFCSKeywordTable keywords = new CFCSKeywordTable();

    // --------------------------------------------------------------------

    private static final /* inner */ class CFCSKeywordTable
    {
        private final List list = new LinkedList();
        private final Map map = new HashMap();

        // ------------------------------------------------------------

        final int size()
        {
            return list.size();
        }

        // ------------------------------------------------------------

        final boolean containsKeyword(final String name)
        {
            return map.containsKey(name.toUpperCase());
        }

        // ------------------------------------------------------------

        final CFCSKeyword getKeyword(final String name)
        {
            return (CFCSKeyword) map.get(name.toUpperCase());
        }

        final CFCSKeyword getKeyword(final int index)
        {
            return (CFCSKeyword) list.get(index);
        }

        // ------------------------------------------------------------

        final void addKeyword(final CFCSKeyword keyword)
        {
            map.put((keyword.getKeywordName()).toUpperCase(), keyword);
            list.add(keyword);
        }

        // ------------------------------------------------------------

        final void deleteKeyword(final String name)
        {
            list.remove(map.remove(name.toUpperCase()));
        }
    }

    // --------------------------------------------------------------------
    // Initial methods that follow actually know where keywords are stored.
    // --------------------------------------------------------------------

    // --------------------------------------------------------------------
    // Returns the total number of keywords currently defined classesbined
    // between TEXT, STEXT and ANALYSIS (and possibly OTHER segments.)

    public final int getCount()
    {
        return keywords.size();
    }

    // --------------------------------------------------------------------
    // Returns the keyword named "name".  (Note: the instance returned
    // is a "copy" of the actual keyword).

    public final CFCSKeyword getKeyword(final String name)
    {
        if (name == null || name.length() == 0)
        { /* 3.2.9 */
            throw new CFCSError(CFCSIllegalName);
        }

        if (keywords.containsKeyword(name))
            return (keywords.getKeyword(name)).copy();
        /* else */ throw new CFCSError(CFCSKeywordNotFound, name);
    }

    // --------------------------------------------------------------------
    // Returns the keyword at index "index".  (Note: the instance returned
    // is a "copy" of the actual keyword).

    public final CFCSKeyword getKeyword(final int index)
    {
        if (index < 0 || index > keywords.size() - 1)
        {
            throw new CFCSError(CFCSBadKeywordIndex, index);
        }

        return keywords.getKeyword(index).copy();
    }

    // --------------------------------------------------------------------
    // Adds the keyword to the current list.  If the keyword already exists,
    // then it is replaced by that specified in the parameter (i.e.,
    // "replaceKeyword" functionality.)

    public final void addKeyword(final CFCSKeyword keyword)
    {
        final String name = keyword.getKeywordName();

        if (SYSTEM_KEYWORDS.contains(name))
        {
            throw new CFCSError(CFCSCannotModifyValue, name);
        }
        else if (CFCSParameters.isParameter(name) || CFCSGatingParameters.isParameter(name))
        {
            throw new CFCSError(CFCSCannotModifyValue, name);
        }
        else if (!keywords.containsKeyword(name))
        {

            String value = keyword.getKeywordValue();
            int segIdx = keyword.getKeywordSource();

            keywords.addKeyword(new CFCSKeyword(name, value, segIdx));
        }
        else
            replaceKeyword(keyword);
    }

    // --------------------------------------------------------------------
    // Deletes the keyword corresponding to "name".
    // If the keyword doesn't exist, then an exception is thrown.

    public final void deleteKeyword(final String name)
    {
        if (name == null || name.length() == 0)
        { /* 3.2.9 */
            throw new CFCSError(CFCSIllegalName);
        }
        else if (SYSTEM_KEYWORDS.contains(name))
        {
            throw new CFCSError(CFCSCannotModifyValue, name);
        }
        else if (keywords.containsKeyword(name))
        {
            keywords.deleteKeyword(name);
        }
        else
            throw new CFCSError(CFCSKeywordNotFound, name);
    }

    // --------------------------------------------------------------------
    // Replaces the keyword with that specified by the parameter.  If the
    // keyword doesn't exist, then an exception is thrown.

    public final void replaceKeyword(final CFCSKeyword keyword)
    {
        final String name = keyword.getKeywordName();

        if (SYSTEM_KEYWORDS.contains(name))
        {
            throw new CFCSError(CFCSCannotModifyValue, name);
        }
        else if (keywords.containsKeyword(name))
        {
            CFCSKeyword existing = keywords.getKeyword(name);
            int segIdx = keyword.getKeywordSource();

            if (segIdx != existing.getKeywordSource())
            {
                throw new CFCSError(CFCSCannotModifySource, segIdx);
            }
            /* else */ existing.setKeywordValue(keyword.getKeywordValue());
        }
        else
            throw new CFCSError(CFCSKeywordNotFound, name);
    }

    // --------------------------------------------------------------------
    // Friendly methods that bypass safety checks and avoid copying.
    // --------------------------------------------------------------------

    // --------------------------------------------------------------------
    // Fast, non-copying keyword lookup routines for friends who need to
    // loop over lots of keywords quickly.

    /* friendly */
    final CFCSKeyword getSystemKeyword(final String name)
    {

        if (keywords.containsKeyword(name))
            return keywords.getKeyword(name);

        return null;
    }

    /* friendly */
    final CFCSKeyword getSystemKeyword(final int index)
    {
        return keywords.getKeyword(index);
    }

    // --------------------------------------------------------------------
    // Adds the keyword to the current list.  If the keyword already exists,
    // then replaceSystemKeyword() is called instead.  Doesn't copy data and
    // allows any keyword to be set.

    /* friendly */
    final void addSystemKeyword(final CFCSKeyword keyword)
    {
        if (!keywords.containsKeyword(keyword.getKeywordName()))
        {
            keywords.addKeyword(keyword);
        }
        else
            replaceSystemKeyword(keyword);
    }

    // --------------------------------------------------------------------
    // Replaces the keyword with that specified by the parameter.  If the
    // keyword doesn't exist, then an exception is thrown.  Allows any
    // value to be reset.

    /* friendly */
    final void replaceSystemKeyword(final CFCSKeyword keyword)
    {
        final String name = keyword.getKeywordName();

        if (keywords.containsKeyword(name))
        {
            CFCSKeyword existing = keywords.getKeyword(name);
            int segIdx = keyword.getKeywordSource();

            if (segIdx != existing.getKeywordSource())
            {
                throw new CFCSError(CFCSCannotModifySource, segIdx);
            }
            /* else */ existing.setKeywordValue(keyword.getKeywordValue());
        }
        else
            throw new CFCSError(CFCSKeywordNotFound, name);
    }

    // --------------------------------------------------------------------
    // Methods below don't know where keywords are stored and use the above.
    // --------------------------------------------------------------------

    // --------------------------------------------------------------------
    // Escape (double) delimiters found inside keyword name or value and
    // put a guard character in front of delimiter found at beginning of
    // keyword name or value.  If none found, returns original string.

    private static String escape(final String string, final char delimiter)
    {
        final int length = string.length();
	    int start = 0;
	    int end;
	    final StringBuffer buffer = new StringBuffer();

        if (string.charAt(0) == delimiter)
            buffer.append(DELIMITER_GUARD);

        while (start < length && (end = string.indexOf(delimiter, start)) >= 0)
        {
            (buffer.append(string.substring(start, ++end))).append(delimiter);
            start = end;
        }

        if (start == 0)
            return string;
        /* else */ if (start < length)
            buffer.append(string.substring(start, length));

        return buffer.toString();
    }

    // --------------------------------------------------------------------
    // Pick delimiter that doesn't conflict with keyword names and values if possible.
    // Save it, as we're required to reuse the same one for TEXT, ANALYSIS and STEXT

    private char getDelimiter()
    {
        if (delimiter != DELIMITER_UNDEFINED)
            return delimiter;

        int count = getCount();

        outer: for (int j = 0; j < delimiters.length; j++)
        {
            char character = delimiters[j];

            for (int i = 0; i < count; i++)
            {
                CFCSKeyword keyword = getSystemKeyword(i);

                if ((keyword.getKeywordName()).indexOf(character) > -1 ||
                        (keyword.getKeywordValue()).indexOf(character) > -1)
                {
                    continue outer;
                }
            }

            return (delimiter = character);
        }

        return (delimiter = DEFAULT_DELIMITER);
    }

    // --------------------------------------------------------------------
    // Load data into the keywords from bytes found in a file.

    /* friendly */
    final void setBytes(final byte[] buffer, final int segIdx)
    {
        final char delimiter = (char) buffer[0];
        boolean lastWasDelimiter = false;
        boolean readingKey = true;

        StringBuffer key = new StringBuffer();
        StringBuffer value = new StringBuffer();

        final int length = buffer.length;

        for (int i = 1; i < length; i++)
        {
            char ch = (char) buffer[i];

            if (ch == delimiter)
            {
                if ((lastWasDelimiter = !lastWasDelimiter) == false)
                { // double delimiter == escaped delimiter
                    ((readingKey) ? key : value).append(ch); // put a delimiter in the buffer
                }
            }
            else
            {
                if (lastWasDelimiter)
                {
                    if ((readingKey = !readingKey) == true)
                    {
                        addSystemKeyword(new CFCSKeyword(new String(key), new String(value), segIdx));
                        key = new StringBuffer(); // clear out the buffers
                        value = new StringBuffer();
                    }
                    lastWasDelimiter = false;
                }

                ((readingKey) ? key : value).append(ch);
            }
        }

        if (lastWasDelimiter && !readingKey)
        { // check for encountering a delimiter at the very end
            addSystemKeyword(new CFCSKeyword(new String(key), new String(value), segIdx));
        }
    }

    // --------------------------------------------------------------------
    // Unload data from the keywords in a form that can be stored to file.
    // Returns null if there are no keywords to store in the segIdx segment.

    /* friendly */
    final byte[] getBytes(final int segIdx)
    {
        final char delimiter = getDelimiter();

        final StringBuffer buffer = new StringBuffer();

        final int count = getCount();

        for (int i = 0; i < count; i++)
        {
            CFCSKeyword keyword = getSystemKeyword(i);

            if (keyword.getKeywordSource() == segIdx)
            {
                String name = escape(keyword.getKeywordName(), delimiter);
                String value = escape(keyword.getKeywordValue(), delimiter);

                (((buffer.append(delimiter)).append(name)).append(delimiter)).append(value);
            }
        }

        if (buffer.length() == 0)
            return null;

        buffer.append(delimiter);

        return (buffer.toString()).getBytes();
    }

    // --------------------------------------------------------------------
    // Similar to getBytes() but only for the TEXT segment.  Separately
    // handles FCS-defined keywords ($XYZ) from other keywords when the
    // TEXT segment needs to overflow into an STEXT segment.

    /* friendly */
    final byte[] getTextBytes(final boolean want_fcs_defined)
    {
        final int count = getCount();
        final char delimiter = getDelimiter();
        final StringBuffer buffer = new StringBuffer();

        for (int i = 0; i < count; i++)
        {
            CFCSKeyword keyword = getSystemKeyword(i);

            if (keyword.getKeywordSource() != CFCSDataSet.TEXT)
                continue;

            boolean is_fcs_defined = keyword.isFCSDefined();

            if ((want_fcs_defined && !is_fcs_defined) || (!want_fcs_defined && is_fcs_defined))
                continue;

            String name = escape(keyword.getKeywordName(), delimiter);
            String value = escape(keyword.getKeywordValue(), delimiter);

            (((buffer.append(delimiter)).append(name)).append(delimiter)).append(value);
        }

        if (buffer.length() == 0)
            return null;

        buffer.append(delimiter);

        return (buffer.toString()).getBytes();
    }

    // --------------------------------------------------------------------
    // Front-end onto the $DATATYPE keyword, substitutes a program constant

    /* friendly */
    final int getDatatype()
    {
        String value = null;

        try
        {
            value = (getKeyword(DATATYPE_KEYWORD)).getKeywordValue();
        }
        catch (CFCSError error)
        {
            return CFCSDatatype.UNDEFINED;
        }

        for (int i = 0; i < DATATYPE_LOOKUP_TABLE.length; i++)
        {
            if (value.equalsIgnoreCase((String) DATATYPE_LOOKUP_TABLE[i][LETTER]))
            {
                int type = ((Integer) DATATYPE_LOOKUP_TABLE[i][NUMBER]).intValue();
                return type;
            }
        }

        return CFCSDatatype.UNDEFINED;
    }

    // --------------------------------------------------------------------

    /* friendly */
    final void setDatatype(final int type)
    {
        for (int i = 0; i < DATATYPE_LOOKUP_TABLE.length; i++)
        {
            if (type == ((Integer) DATATYPE_LOOKUP_TABLE[i][NUMBER]).intValue())
            {
                String value = (String) DATATYPE_LOOKUP_TABLE[i][LETTER];
                addSystemKeyword(new CFCSKeyword(DATATYPE_KEYWORD, value));
                return;
            }
        }

        throw new CFCSError(CFCSIllegalValue, type);
    }

    // --------------------------------------------------------------------
    // Front-end onto the $MODE keyword, substitutes a program constant

    /* friendly */
    final int getMode()
    {
        String value = null;

        try
        {
            value = (getKeyword(MODE_KEYWORD)).getKeywordValue();
        }
        catch (CFCSError error)
        {
            return CFCSData.UNDEFINED;
        }

        for (int i = 0; i < MODE_LOOKUP_TABLE.length; i++)
        {
            if (value.equalsIgnoreCase((String) MODE_LOOKUP_TABLE[i][LETTER]))
            {
                return ((Integer) MODE_LOOKUP_TABLE[i][NUMBER]).intValue();
            }
        }

        return CFCSData.UNDEFINED;
    }

    // --------------------------------------------------------------------

    /* friendly */
    final void setMode(final int mode)
    {
        for (int i = 0; i < MODE_LOOKUP_TABLE.length; i++)
        {
            if (mode == ((Integer) MODE_LOOKUP_TABLE[i][NUMBER]).intValue())
            {
                String value = (String) MODE_LOOKUP_TABLE[i][LETTER];
                addSystemKeyword(new CFCSKeyword(MODE_KEYWORD, value));
                return;
            }
        }

        throw new CFCSError(CFCSIllegalValue, mode);
    }

    // --------------------------------------------------------------------
    // Convert from $BYTEORD string value to an array

    protected final int[] getByteSwapArray()
    {
        final CFCSKeyword keyword = getSystemKeyword(BYTEORDER_KEYWORD);

        final String string = keyword.getKeywordValue();

        final List positions = new LinkedList();

        for (int i = 0; i < string.length(); i++)
        {
            char character = string.charAt(i);

            if (Character.isDigit(character))
            {
                positions.add(new Integer(Character.digit(character, 10)));
            }
        }

        final int[] array = new int[positions.size()];

        for (int i = 0; i < array.length; i++)
            array[i] = ((Integer) positions.get(i)).intValue();

        return array;
    }

    // --------------------------------------------------------------------
    // Convert from an array to a string value for $BYTEORD

    protected final void setByteSwapArray(final int[] array)
    {
        final StringBuffer buffer = new StringBuffer();

        for (int i = 0; i < array.length; i++)
        {
            buffer.append(array[i]);

            if (i < (array.length - 1))
                buffer.append(CFCSSystem.VALUE_SEPARATOR_CHAR);
        }

        addSystemKeyword(new CFCSKeyword(BYTEORDER_KEYWORD, buffer.toString()));
    }

    // --------------------------------------------------------------------

}
